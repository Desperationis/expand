#!/usr/bin/env bash
set -euo pipefail

SESSION="work"
n="${1:-1}"

# Run in a dedicated tmux session so kill_all_unused_terminals.bash
# (which only targets the "default" session) won't close it.
if [ "$(tmux display-message -p '#S' 2>/dev/null)" != "$SESSION" ]; then
  tmux kill-session -t "$SESSION" 2>/dev/null || true
  if [ -n "${TMUX:-}" ]; then
    tmux new-session -d -s "$SESSION" -c "$(pwd)" "$0 $n"
    exec tmux switch-client -t "$SESSION"
  else
    exec tmux new-session -s "$SESSION" -c "$(pwd)" "$0 $n"
  fi
fi

trap 'kill 0' SIGINT

for ((i = 1; i <= n; i++)); do
  printf '\033[1;34m=== Run %d of %d ===\033[0m\n\n' "$i" "$n"
  claude --dangerously-skip-permissions --verbose -p "/find-next" --output-format stream-json | while IFS= read -r line; do
    type=$(printf '%s' "$line" | jq -r '.type // empty' 2>/dev/null) || continue
    case "$type" in
      assistant)
        printf '%s' "$line" | jq -r '
          .message.content[] |
          if .type == "text" then
            "\u001b[2m" + .text + "\u001b[0m"
          elif .type == "tool_use" then
            "  \u001b[33m[\(.name)]\u001b[0m " + (
              if .name == "Bash" then
                (.input.command // "" | split("\n")[0] |
                  if length > 70 then .[:70] + "..." else . end)
              elif .name == "Read" then (.input.file_path // "")
              elif .name == "Edit" then (.input.file_path // "")
              elif .name == "Write" then (.input.file_path // "")
              elif .name == "Glob" then (.input.pattern // "")
              elif .name == "Grep" then "/" + (.input.pattern // "") + "/"
              elif .name == "Task" then (.input.description // "")
              elif .name == "Skill" then (.input.skill // "")
              else ""
              end)
          else empty
          end
        ' 2>/dev/null || true
        ;;
      result)
        turns=$(printf '%s' "$line" | jq -r '.num_turns // 0' 2>/dev/null) || true
        cost=$(printf '%s' "$line" | jq -r '.total_cost_usd // 0' 2>/dev/null) || true
        dur=$(printf '%s' "$line" | jq -r '((.duration_ms // 0) / 1000 | . * 10 | round / 10)' 2>/dev/null) || true
        err=$(printf '%s' "$line" | jq -r '.is_error // false' 2>/dev/null) || true
        if [ "$err" = "true" ]; then
          sub=$(printf '%s' "$line" | jq -r '.subtype // "error"' 2>/dev/null) || true
          printf '\n\033[33m── done (%s) ──\033[0m\n' "$sub"
        else
          printf '\n\033[32m── done ──\033[0m\n'
        fi
        printf '  \033[2m%s turns | $%s | %ss\033[0m\n\n' "$turns" "$cost" "$dur"
        ;;
    esac
  done
done
